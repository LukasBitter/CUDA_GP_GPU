#pragma once

#include <math.h>
#include "MathTools.h"
#include <iostream>
#include <complex>

#include "Calibreur_GPU.h"
#include "ColorTools_GPU.h"

using namespace gpu;

using std::cout;
using std::endl;

/*----------------------------------------------------------------------*\
 |*			Declaration 					*|
 \*---------------------------------------------------------------------*/

/*--------------------------------------*\
 |*		Public			*|
 \*-------------------------------------*/

class NewtonMath
    {

	/*--------------------------------------*\
	|*		Constructor		*|
	 \*-------------------------------------*/

    public:

	__device__ NewtonMath(uint n) :
		calibreur(Interval<float>(0, n), Interval<float>(0, 1))
	    {
	    this->n = n;
	    }

	// constructeur copie automatique car pas pointeur dans
	//	NewtonMath
	// 	calibreur
	// 	IntervalF

	__device__
	    virtual ~NewtonMath()
	    {
	    // rien
	    }

	/*--------------------------------------*\
	|*		Methodes		*|
	 \*-------------------------------------*/

    public:

	__device__
	void colorXY(uchar4* ptrColor, float x, float y)
	    {
	    int z = next(x, y);

	    if (z < n)
		{
		float hue01 = z;
		calibreur.calibrer(hue01);
		ColorTools::HSB_TO_RVB(hue01, ptrColor); // update color
		}
	    else
		{
		ptrColor->x = 0;
		ptrColor->y = 0;
		ptrColor->z = 0;
		}

	    ptrColor->w = 255; // opaque
	    }
    private:

	// F(x) = x ^ NumRoots - 1.
	complex<float> F(complex<float> x)
	{
	    return (x ^ (complex<float>)NumRoots) - 1;
	}

	// dFdx(x) = NumRoots * x ^ (NumRoots - 1).
	complex<float> dFdx(complex<float> x)
	{
	    return NumRoots * (x ^ (complex<float>)(NumRoots - 1));
	}

	__device__
	int next(float Wmin, float Wymin)
	    {
		Complex x0 = new Complex(Wxmin, 0);
		for (int i = 0; i < wid; i++)
		{
		    x0.Im = Wymin;
		    for (int j = 0; j < hgt; j++)
		    {
			Complex x = x0;
			Complex epsilon;
			const int max_iter = 400;
			int iter = 0;
			do
			{
			    if (++iter > n) break;
			    epsilon = -(F(x) / dFdx(x));
			    x += epsilon;
			} while (epsilon.MagnitudeSquared() > cutoff);

			// Set the color.
			int clr = 0;
			if (iter <= max_iter)
			{
			    // Find the closest root.
			    for (int r = 0; r <= Roots.GetUpperBound(0); r++)
			    {
				if (x.IsCloseTo(Roots[r]))
				{
				    // Set the pixel's color.
				    clr = r % Colors.Length;
				    break;
				}
			    }
			}
			Bm.SetPixel(i, j, Colors[clr]);

			// Move to the next point.
			x0.Im += dy;
		    } // For j
		    x0.Re += dx;

		    // Let the user know we're not dead.
		    if (i % 10 == 0) picCanvas.Refresh();
		} // For i
	    }

	/*--------------------------------------*\
	|*		Attributs		*|
	 \*-------------------------------------*/

    protected:

	// Input
	uint n;

    private:

	// Tools
	Calibreur<float> calibreur;

    };
/*----------------------------------------------------------------------*\
 |*			End	 					*|
 \*---------------------------------------------------------------------*/

